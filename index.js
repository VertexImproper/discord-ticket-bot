const { Client, GatewayIntentBits, Partials, Collection, ChannelType, PermissionFlagsBits, EmbedBuilder } = require('discord.js'); const fs = require('fs'); const path = require('path'); const config = require('./config.json'); const client = new Client({ intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.GuildMembers], partials: [Partials.Channel], }); client.commands = new Collection(); const commandsPath = path.join(__dirname, 'commands'); const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js')); for (const file of commandFiles) { const filePath = path.join(commandsPath, file); const command = require(filePath); client.commands.set(command.data.name, command); } client.once('ready', () => { console.log(`[BOT] Logged in as ${client.user.tag}`); console.log(`[BOT] Supporting ${config.guilds.length} guild(s)`); }); function getGuildConfig(guildId) { return config.guilds.find(g => g.guildId === guildId); } client.on('interactionCreate', async interaction => { if (interaction.isChatInputCommand()) { const command = client.commands.get(interaction.commandName); if (!command) return; try { await command.execute(interaction); } catch (error) { console.error(error); if (interaction.replied || interaction.deferred) { await interaction.followUp({ content: 'Error executing command.', ephemeral: true }); } else { await interaction.reply({ content: 'Error executing command.', ephemeral: true }); } } } if (interaction.isButton() && interaction.customId.startsWith('ticket_open_')) { const guildConfig = getGuildConfig(interaction.guildId); if (!guildConfig) { return interaction.reply({ content: 'Guild not configured.', ephemeral: true }); } const index = parseInt(interaction.customId.split('_')[2], 10); const categoryName = guildConfig.ticketGuiCategories[index] || 'Ticket'; const guild = interaction.guild; let parentCategory = guildConfig.ticketCategoryId ? guild.channels.cache.get(guildConfig.ticketCategoryId) : null; if (!parentCategory) { parentCategory = await guild.channels.create({ name: 'Tickets', type: ChannelType.GuildCategory, }); guildConfig.ticketCategoryId = parentCategory.id; fs.writeFileSync('./config.json', JSON.stringify(config, null, 2)); } const staffOverwrites = []; for (const staffRoleId of guildConfig.staffRoleIds) { staffOverwrites.push({ id: staffRoleId, allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages], }); } const ticketChannel = await guild.channels.create({ name: `${categoryName.toLowerCase()}-${interaction.user.username}`, type: ChannelType.GuildText, parent: parentCategory.id, permissionOverwrites: [ { id: guild.roles.everyone.id, deny: [PermissionFlagsBits.ViewChannel], }, { id: interaction.user.id, allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages], }, ...staffOverwrites, ], }); const embed = new EmbedBuilder() .setTitle(`${categoryName} Ticket`) .setDescription('Staff will be with you shortly.\nUse `/close` when done.') .setColor(0x57f287); await ticketChannel.send({ content: `<@${interaction.user.id}>`, embeds: [embed] }); await interaction.reply({ content: `Ticket created: ${ticketChannel}`, ephemeral: true }); } }); client.login(config.token);
